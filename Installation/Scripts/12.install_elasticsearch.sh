#!/bin/bash
# Install and configure Logstash and Elasticsearch

wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
sudo apt-get install apt-transport-https -y
echo "deb https://artifacts.elastic.co/packages/7.x/apt stable main" | sudo tee /etc/apt/sources.list.d/elastic-7.x.list

# Install elastic
sudo apt-get update && sudo apt-get install elasticsearch -y
# Install logsatsh
sudo apt-get install logstash -y
# Install tshark
sudo apt-get install tshark -y

# The configurations of Logstash are stored in the /etc/logsatsh/conf.d folder
sudo tee /etc/logstash/conf.d/tshark.conf > /dev/null << 'EOF'
input {
  tcp {
    port => 17570
  }
}

filter {
  # Ignore index lines
  if ([message] =~ "{\"index") {
    drop {}
  }

  # Use Json message parser and not codec
  json {
    source => "message"
  }

  date {
    match => [ "timestamp", "UNIX_MS" ]
  }

  mutate {
    # remove the original json
    remove_field => [ "json", "message" ]
  }
}

output {  
  elasticsearch {
    index => "freshinstall"
    hosts => ["http://localhost:9200"]
  }
} 

EOF

sudo pip install psutil

sudo tee /usr/local/bin/capture_trafic.py > /dev/null << 'EOF'
"""
Script to make the setup of traffic capture easier
"""
import psutil
import os
import subprocess
import re
import time
import socket


def check_is_digit(input_str):
    """
    Will check if user as entered 1 or 2 as input
    Args:
        input_str (str): Contains the input of the user

    Returns:
        True if the input is the int 1 or 2. False otherwise.
    """
    if input_str.strip().isdigit():
        if int(input_str) == 1 or int(input_str) == 2:
            return True
    return False


def check_logstash_name(input_str):
    """
    Will check if user as entered a correct index for logstash
    Args:
        input_str (str): Contains the input of the user

    Returns:
        True if the input is correct. False otherwise
    """
    if not input_str.islower():
        print("Name must be lowercase only")
        return False
    if '\\' in input_str or '/' in input_str or '*' in input_str or '?' in input_str or '"' in input_str \
            or '#' in input_str or '<' in input_str or '>' in input_str or '|' in input_str or ' ' in input_str \
            or ',' in input_str:
        print("Name must not include \\, /, *, ?, \", <, >, |, ` ` (space character), ',' (comma) , #")
        return False
    if input_str[0] == '-' or input_str[0] == '_' or input_str[0] == '+' or input_str[0] == '.':
        print("Name cannot start with -, _, + and .")
        return False
    if input_str == "." or input_str == "..":
        print("Name cannot be . or ..")
        return False
    if len(input_str.encode('utf-8')) > 255:
        print("Name cannot be higher that 255 bytes")
        return False
    return True


def get_file_name(result):
    """
    Get the name of the pcap file generated by dumcap
    Args:
        result (str): Contains the output of the command dumpcap

    Returns:
        The name of the file if found if not return an empty string
    """
    # Usage of a regex to find the name of the file
    rx = re.compile('^File: (\S+)$', re.MULTILINE)
    m = rx.search(result)
    # If file is found get the 2 group that will be the name of the file
    if m:
        file_name = m.group(1)
        return file_name
    return ""


def wait_for_port(port, host='localhost', timeout=120.0):
    """
    Wait until a port starts accepting TCP connections.
    Args:
        port (int): Port number.
        host (str): Host address on which the port should exist.
        timeout (float): In seconds. How long to wait before raising errors.

    Raises:
        TimeoutError: The port isn't accepting connection after time specified in `timeout`.
    """
    start_time = time.perf_counter()
    while True:
        try:
            # If the socket is created break
            with socket.create_connection((host, port), timeout=timeout):
                break
        except OSError as ex:
            time.sleep(0.01)
            # Check that the time has not passed the timeout if that is the case return an Error
            if time.perf_counter() - start_time >= timeout:
                raise TimeoutError('Waited too long for the port {} on host {} to start accepting '
                                   'connections.'.format(port, host)) from ex


def modify_conf_file(filename):
    """
    Change the name of the file that will be created by Logstash
    Args:
        filename: name of the file that Logstash will generate
    """
    # Read the current config file
    f = open('/etc/logstash/conf.d/tshark.conf', 'r')
    # Read the files per line
    filedata = f.readlines()
    f.close()
    # Change the value of index line to change the name of the file
    for i in range(0, len(filedata)):
        if "index =>" in filedata[i]:
            filedata[i] = "    index => \"" + filename + "\"\n"

    # Write the new config
    f = open('/etc/logstash/conf.d/tshark.conf', 'w')
    f.writelines(filedata)
    f.close()


# Get the total RAM minus the used RAM to see if we can run the live method
ramAvailable = round(psutil.virtual_memory()[1] / 1000000000, 2)
print("RAM Available in GB", ramAvailable)
# After some tests, of the RAM is below 8.00 GB it is preferable to use the 2 method
if ramAvailable < 8.00:
    print("It will be better for you to choose the second method because the first one uses a lot of RAM and this "
          "could cause your PC to slow-down")
print("====================================")
print("Choose the method you want to use")
print("[1] Live Method consumes a lot of RAM")
print("[2] Capture mode can create a file with 1GB of size be careful with the disk space")

# Enter the method to use
while True:
    num = input("Enter our choice : ")
    if check_is_digit(num):
        num = int(num)
        break

# Enter the name of the capture
while True:
    filename = input("Enter the name of the capture : ")
    if check_logstash_name(filename):
        filename_correct = filename
        break

# Change the config file of Logstash with the filename entered
modify_conf_file(filename_correct)

# Check if Elasticsearch is already running. If not start the service
if os.system('systemctl is-active --quiet elasticsearch') == 0:
    print("ElasticSearch is already running")
else:
    print("Starting Elasticsearch...")
    os.system('service elasticsearch start')
    print("Elasticsearch started")
# Start the Logstash service and wait for it to respond on the port 17570
print("Starting Logstash...")
os.system('service logstash start')
wait_for_port(17570)
print("Logstash started")

print("Capture has started")
print("Press Ctrl-C to stop the captures")

if num == 1:
    print("The capture will be available in elasticsearch with the name", filename_correct)
    # ***EDIT***
    # Be careful to change the interface to the correct one because if not the capture will not work
    os.system('sudo tshark -i ens34 -f"tcp port 8080" -T ek -Y http | netcat localhost 17570')
else:
    # Create a subprocess that will start dumpcap
    # ***EDIT***
    # Be careful to change the interface to the correct one because if not the capture will not work
    proc = subprocess.Popen('dumpcap -i ens34 -f"tcp port 8080" -a filesize:1000000', shell=True,
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    try:
        # Get the name of the file that will be generated by dumpcap
        for line in proc.stderr:
            if b'File: ' in line:
                filename_pcap = get_file_name(line.decode("utf-8"))
                print("Name of the pcap file :", filename_pcap)
    except KeyboardInterrupt:
        # Wait for Interrupt to kill the process to react like the first method
        proc.kill()
        print()
# If the second method is used send the file to Logstash
if num == 2:
    command = 'sudo tshark -r ' + filename_pcap + ' -T ek -Y http | netcat localhost 17570 -w10'
    os.system(command)
    print("The capture is now available in elasticsearch with the name", filename_correct)

# Stop the Logstash service
print("Stoping Logstash...")
os.system('service logstash stop')
print("Logstash stopped")

EOF